generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String               @id @default(cuid())
  clerkId                String               @unique
  email                  String               @unique
  username               String               @unique
  photo                  String
  firstName              String?
  lastName               String?
  stripeCustomerId       String?
  planId                 Int                  @default(1)
  // Subscription plan management
  pendingPlanId          String? // Stores downgrade plan ID until renewal (references SubscriptionPlan.id)
  entitlementLevel       String? // User entitlement level (if used for feature flags/limits)
  // User roles and permissions
  role                   UserRole             @default(USER)
  isActive               Boolean              @default(true)
  // User-scoped credits (for personal accounts)
  creditBalance          Int                  @default(10)
  lowBalanceThreshold    Int                  @default(5)
  autoTopUpEnabled       Boolean              @default(false)
  autoTopUpAmountCredits Int?
  creditBalanceVersion   Int                  @default(0)
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt
  ledger                 CreditLedger[]
  jobQuotes              JobQuote[]
  jobs                   Job[]
  organizationMembers    OrganizationMember[]
  transactions           Transaction[]
  trendingImports        TrendingImportLog[]
  creditGrants           CreditGrant[]
  subscriptions          UserSubscription[]
  topUpPurchases         TopUpPurchase[]
  favoriteProducts       UserFavoriteProduct[]

  @@map("users")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

model Organization {
  id        String               @id @default(cuid())
  clerkId   String               @unique
  name      String
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt
  credits   CreditBalance?
  ledger    CreditLedger[]
  jobQuotes JobQuote[]
  jobs      Job[]
  members   OrganizationMember[]

  @@map("organizations")
}

model OrganizationMember {
  id             String       @id @default(cuid())
  organizationId String
  userId         String
  role           String       @default("member")
  createdAt      DateTime     @default(now())
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@map("organization_members")
}

model CreditBalance {
  id                     String       @id @default(cuid())
  organizationId         String       @unique
  balance                Int          @default(0)
  lowBalanceThreshold    Int          @default(10)
  autoTopUpEnabled       Boolean      @default(false)
  autoTopUpAmountCredits Int?
  version                Int          @default(0)
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  organization           Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@map("credit_balances")
}

model CreditLedger {
  id             String       @id @default(cuid())
  organizationId String
  userId         String?
  jobId          String?
  type           String
  amount         Int
  reason         String
  metadata       Json?
  idempotencyKey String?      @unique
  externalJobId  String?
  clientId       String?
  environment    String       @default("production")
  breakdown      Json?
  balanceAfter   Int?
  status         String       @default("completed")
  createdAt      DateTime     @default(now())
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user           User?        @relation(fields: [userId], references: [id])

  @@map("credit_ledger")
}

model PriceBookEntry {
  id          String   @id @default(cuid())
  pipelineKey String
  creditCost  Int
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([pipelineKey])
  @@map("price_book")
}

model Job {
  id                     String       @id @default(cuid())
  organizationId         String
  userId                 String
  workflowId             String?
  status                 String       @default("pending")
  title                  String
  description            String?
  quotedCredits          Int?
  quotedAt               DateTime?
  confirmedAt            DateTime?
  startedAt              DateTime?
  completedAt            DateTime?
  failedAt               DateTime?
  totalInternalCostUsd   Float?
  totalRetailCostCredits Int?
  resultUrl              String?
  errorMessage           String?
  metadata               Json?
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  organization           Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user                   User         @relation(fields: [userId], references: [id])

  @@map("jobs")
}

model Transaction {
  id        String   @id @default(cuid())
  userId    String
  stripeId  String   @unique
  amount    Float
  plan      String?
  credits   Int?
  status    String   @default("completed")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("transactions")
}

model JobQuote {
  id             String       @id @default(cuid())
  organizationId String
  userId         String
  workflowType   String
  parameters     Json
  totalCredits   Int
  breakdown      Json
  expiresAt      DateTime
  status         String       @default("active")
  createdAt      DateTime     @default(now())
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id])

  @@map("job_quotes")
}

model TrendingProduct {
  id               String               @id @default(cuid())
  tiktokProductId  String               @unique
  name             String
  tiktokProductUrl String
  displayImageUrl  String
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  weekStats        ProductWeekStat[]
  matches          ProductAmazonMatch[]
  videos           TrendingVideo[]
  favoritedBy      UserFavoriteProduct[]

  @@map("products")
}

model WeeklyReport {
  id            String              @id @default(cuid())
  weekStartDate DateTime
  weekEndDate   DateTime
  label         String
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  stats         ProductWeekStat[]
  importLogs    TrendingImportLog[]

  @@unique([weekStartDate, weekEndDate])
  @@map("weekly_reports")
}

model ProductWeekStat {
  id                 String          @id @default(cuid())
  reportId           String
  productId          String
  rankThisWeek       Int?
  tiktokSales7d      Int?
  tiktokDailySales   Int?
  amazonSales7d      Int?
  snapshotPriceCents Int?
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  report             WeeklyReport    @relation(fields: [reportId], references: [id], onDelete: Cascade)
  product            TrendingProduct @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([reportId, productId])
  @@map("product_week_stats")
}

model AmazonProduct {
  // Primary identifiers
  asin         String  @id
  locale       String? // e.g., "US"
  marketplace  String? // e.g., "amazon.com"
  productUrl   String? // Full product URL (from product.url)
  canonicalUrl String? // Keep for backward compatibility

  // Product metadata
  version   String? // Scraper version (from meta.scraper_version)
  source    String?   @default("amazon")
  scrapedAt DateTime? // When the data was scraped (from scraped_at)

  // Basic product info
  title               String?
  brand               String?
  categoryPath        Json? // Array of category strings (from product.categories)
  descriptionText     String? @db.Text // from product.copy.long_description_text
  shortDescription    String? @db.Text // from product.copy.short_description
  longDescriptionHtml String? @db.Text // from product.copy.long_description_html
  bullets             Json? // Array of bullet point strings (from product.copy.bullet_points)

  // Images & Media
  mainImageUrl String? // from product.media.primary_image_url
  allImages    Json? // Array of image objects (from product.media.images)
  videos       Json? // Array of video objects (from product.media.videos)

  // Pricing
  salePrice    Float? // from product.price.current
  listPrice    Float? // from product.price.list
  currency     String? // from product.price.currency
  priceDisplay String? // Keep for backward compatibility

  // Availability
  availabilityStatus String? // from product.availability.status
  availabilityText   String? // from product.availability.text

  // Engagement metrics
  customersUsuallyKeepPercentage Float?
  customersUsuallyKeepRaw        String?
  unitsSoldDisplay               String? // e.g., "2K+ bought"
  unitsSoldNumericEstimate       Int? // e.g., 2000

  // Ratings
  averageRating Float? // from product.social_proof.rating.value
  ratingScale   Float? // from product.social_proof.rating.scale
  totalRatings  Int? // from product.social_proof.rating.count

  // Badges
  isPrime            Boolean? @default(false) // from product.badges.is_prime
  isBestSeller       Boolean? @default(false) // from product.badges.is_best_seller
  isAmazonChoice     Boolean? @default(false) // from product.badges.is_amazon_choice
  hasCoupon          Boolean? @default(false) // from product.badges.has_coupon
  hasLimitedTimeDeal Boolean? @default(false) // from product.badges.has_limited_time_deal

  // Source metadata (from source object)
  sourceType         String? // from source.type
  sourceActor        String? // from source.actor
  sourceSubmittedBy  String? // from source.submitted_by
  sourceIngestMethod String? // from source.ingest_method
  sourceTimestamp    DateTime? // from source.timestamp

  // Meta metadata (from meta object)
  rawHtmlIncluded Boolean? @default(false) // from meta.raw_html_included
  metaNotes       String?  @db.Text // from meta.notes

  // Related products
  relatedProducts Json? // { similar_items: [], related_asins: [] }

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  matches ProductAmazonMatch[]
  reviews AmazonProductReview[]

  @@index([locale, marketplace])
  @@index([scrapedAt])
  @@index([sourceType])
  @@map("amazon_products")
}

model AmazonProductRawJson {
  id            String   @id @default(cuid())
  asin          String
  source        String   @default("apify_actor")
  schemaVersion String? // e.g., "1.1"
  json          Json // Full JSON payload (JSONB)
  status        String?  @default("pending") // pending, processed, failed, archived
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([asin])
  @@index([source])
  @@index([schemaVersion])
  @@index([status])
  @@index([createdAt])
  @@map("amazon_product_raw_json")
}

model AmazonProductReview {
  id         String        @id @default(cuid())
  asin       String
  rating     Float // 1.0 to 5.0
  starRating Int // 1, 2, 3, 4, or 5 (for easy filtering)
  reviewer   String? // Reviewer name
  title      String? // Review title
  body       String?       @db.Text // Review body text
  date       String? // e.g., "Reviewed in Mexico on April 30, 2023"
  verified   String? // e.g., "Verified Purchase"
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  product    AmazonProduct @relation(fields: [asin], references: [asin], onDelete: Cascade)

  @@index([asin, starRating])
  @@index([asin, rating])
  @@map("amazon_product_reviews")
}

model ProductAmazonMatch {
  id         String          @id @default(cuid())
  productId  String
  asin       String
  confidence Float           @default(0.5)
  source     String          @default("kalodata")
  chosen     Boolean         @default(false)
  matchedAt  DateTime        @default(now())
  method     String?
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  product    TrendingProduct @relation(fields: [productId], references: [id], onDelete: Cascade)
  amazon     AmazonProduct   @relation(fields: [asin], references: [asin], onDelete: Cascade)

  @@unique([productId, asin])
  @@map("product_amazon_matches")
}

model TrendingVideo {
  id             String          @id @default(cuid())
  url            String          @unique
  productId      String
  rankForProduct Int?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  product        TrendingProduct @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@map("videos")
}

model TrendingImportLog {
  id            String        @id @default(cuid())
  fileLabel     String
  uploaderId    String?
  status        ImportStatus  @default(PENDING)
  rowsProcessed Int           @default(0)
  rowsCreated   Int           @default(0)
  rowsUpdated   Int           @default(0)
  rowsSkipped   Int           @default(0)
  rowsFlagged   Int           @default(0)
  notes         Json?
  startedAt     DateTime      @default(now())
  completedAt   DateTime?
  reportId      String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  report        WeeklyReport? @relation(fields: [reportId], references: [id])
  uploader      User?         @relation(fields: [uploaderId], references: [id])

  @@map("import_logs")
}

model UserFavoriteProduct {
  id        String          @id @default(cuid())
  userId    String
  productId String
  createdAt DateTime        @default(now())
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  product   TrendingProduct @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
  @@index([userId])
  @@map("user_favorite_products")
}

enum ImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum CreditType {
  SUBSCRIPTION
  TOPUP
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  UNPAID
  TRIALING
}

// CreditGrant: Tracks individual credit grants with expiry dates
// This is the core model for credit expiry and type tracking
model CreditGrant {
  id              String            @id @default(cuid())
  userId          String
  type            CreditType // SUBSCRIPTION or TOPUP
  amount          Int // Total credits granted
  usedAmount      Int               @default(0) // Credits used from this grant
  grantedAt       DateTime          @default(now())
  expiresAt       DateTime // When this grant expires
  planId          String? // Reference to SubscriptionPlan or TopUpPlan
  subscriptionId  String? // If from subscription, link to UserSubscription
  topUpPurchaseId String? // If from top-up, link to TopUpPurchase
  ledgerId        String? // Link to the CreditLedger entry that created this grant
  metadata        Json? // Additional metadata (stripe invoice ID, etc.)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription    UserSubscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  topUpPurchase   TopUpPurchase?    @relation(fields: [topUpPurchaseId], references: [id], onDelete: SetNull)

  @@index([userId, expiresAt])
  @@index([userId, type, expiresAt])
  @@map("credit_grants")
}

// SubscriptionPlan: Defines subscription plans with versioning support
model SubscriptionPlan {
  id                    String             @id @default(cuid())
  planFamily            String // e.g., "basic", "pro", "enterprise"
  version               Int                @default(1) // Version number for this plan
  internalId            String             @unique // e.g., "sub_basic_v1", "sub_basic_v2"
  publicName            String // e.g., "Starter Plan", "Pro Plan"
  priceUsd              Float // Monthly price in USD
  creditsPerCycle       Int // Credits granted per billing cycle
  creditExpiryDays      Int                @default(30) // Days until credits expire (default 30 for subscriptions)
  stripePriceId         String?            @unique // Stripe Price ID
  stripeProductId       String? // Stripe Product ID
  isActiveForNewSignups Boolean            @default(true) // Can new users sign up for this?
  isLegacyOnly          Boolean            @default(false) // Only existing subscribers can stay on this
  isHidden              Boolean            @default(false) // Hide from UI (for testing/internal)
  isDefaultForSignup    Boolean            @default(false) // Default plan for new signups
  upgradeAllowedTo      String[]           @default([]) // Array of plan IDs user can upgrade to
  downgradeAllowedTo    String[]           @default([]) // Array of plan IDs user can downgrade to
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  subscriptions         UserSubscription[]

  @@unique([planFamily, version])
  @@index([planFamily, isActiveForNewSignups])
  @@map("subscription_plans")
}

// TopUpPlan: Defines one-time top-up credit packs
model TopUpPlan {
  id                             String          @id @default(cuid())
  internalId                     String          @unique // e.g., "topup_5000_v1"
  publicName                     String // e.g., "5,000 Credit Boost"
  priceUsd                       Float // Price in USD
  creditsGranted                 Int // Credits granted
  creditExpiryDays               Int             @default(365) // Days until credits expire (default 365 for top-ups)
  stripePriceId                  String?         @unique // Stripe Price ID
  stripeProductId                String? // Stripe Product ID
  canPurchaseWithoutSubscription Boolean         @default(true) // Can non-subscribers buy this?
  isActive                       Boolean         @default(true)
  isHidden                       Boolean         @default(false)
  createdAt                      DateTime        @default(now())
  updatedAt                      DateTime        @updatedAt
  purchases                      TopUpPurchase[]

  @@map("top_up_plans")
}

// UserSubscription: Tracks active user subscriptions
model UserSubscription {
  id                   String             @id @default(cuid())
  userId               String
  planId               String // Reference to SubscriptionPlan
  stripeSubscriptionId String             @unique // Stripe Subscription ID
  status               SubscriptionStatus @default(ACTIVE)
  currentPeriodStart   DateTime // Start of current billing period
  currentPeriodEnd     DateTime // End of current billing period (renewal date)
  cancelAtPeriodEnd    Boolean            @default(false) // Will cancel at period end
  canceledAt           DateTime? // When subscription was canceled
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan                 SubscriptionPlan   @relation(fields: [planId], references: [id])
  creditGrants         CreditGrant[]

  @@index([userId, status])
  @@index([stripeSubscriptionId])
  @@map("user_subscriptions")
}

// TopUpPurchase: Tracks individual top-up purchases
model TopUpPurchase {
  id              String        @id @default(cuid())
  userId          String
  planId          String // Reference to TopUpPlan
  stripeSessionId String? // Stripe Checkout Session ID
  stripeInvoiceId String? // Stripe Invoice ID
  amount          Float // Amount paid
  creditsGranted  Int // Credits granted
  purchasedAt     DateTime      @default(now())
  expiresAt       DateTime // When credits expire (purchasedAt + creditExpiryDays)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan            TopUpPlan     @relation(fields: [planId], references: [id])
  creditGrants    CreditGrant[]

  @@index([userId, expiresAt])
  @@index([stripeSessionId])
  @@map("top_up_purchases")
}
